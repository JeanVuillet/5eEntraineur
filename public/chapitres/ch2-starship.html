<template id="template-starship-game">
  <style>
    .question-zone { 
      margin: 8px 0;
      font-size: 1.5em; 
      text-align: center; 
      min-height: 2.5em; 
    }
    
    #starship-game-area {
      position: relative;
      /* Hauteur r√©duite pour mieux voir la barre de temps au-dessus */
      height: clamp(320px, 50vh, 550px); 
      background: #0c0a18;
      border-radius: 12px;
      overflow: hidden;
      cursor: crosshair;
      margin-top: 10px;
    }
    
    #ship {
      position: absolute;
      bottom: 10px;
      left: 50%;
      width: 60px;
      height: 60px;
      transform: translateX(-50%);
      background: url('/images/ship.png') center/contain no-repeat;
      transition: left 0.1s linear;
    }

    .falling-answer {
      position: absolute;
      top: -80px;
      padding: 10px 20px;
      background: #333;
      color: white;
      border: 2px solid #00f2ff;
      border-radius: 8px;
      font-weight: bold;
      /* Chaque r√©ponse est centr√©e sur sa ‚Äúvoie‚Äù horizontale */
      transform: translateX(-50%);
      animation: fall linear forwards;
      white-space: nowrap;
    }

    @keyframes fall {
      from { top: -80px; }
      to { top: 100%; }
    }

    .missile {
      position: absolute;
      width: 8px;
      height: 25px;
      background-color: #ffeb3b;
      border-radius: 4px;
      box-shadow: 0 0 10px #ffeb3b;
    }
  </style>
  
  <div id="question" class="question-zone"></div>
  <div id="starship-game-area">
    <div id="ship"></div>
  </div>
</template>

<script>
/**
 * Jeu Starship : les r√©ponses tombent, le joueur tire avec [ESPACE].
 * On synchronise la vitesse de chute et le timeout via STARSHIP_FALL_DURATION.
 * On a RALENTI la chute (~ +40% de dur√©e).
 */
const STARSHIP_FALL_DURATION = 65000; // 65s ‚âà vitesse r√©duite de ~40%

class StarshipGame {
  constructor(container, controller) {
    this.container = container;
    this.controller = controller;

    this.gameArea = container.querySelector("#starship-game-area");
    this.ship = container.querySelector("#ship");
    this.questionElement = container.querySelector("#question");

    this.missiles = [];
    this.answers = [];
    this.currentQuestion = null;
    this.animationFrameId = null;
    this.timeoutId = null;

    this.bindControls();
  }

  loadQuestion(question) {
    this.currentQuestion = question;
    this.questionElement.textContent = question.q;
    this.clearObjects();
    this.spawnAnswers();
  }

  bindControls() {
    document.addEventListener("keydown", (e) => {
      if (this.controller.getState().isLocked) return;

      if (e.key === "ArrowLeft") this.moveShip(-40);
      if (e.key === "ArrowRight") this.moveShip(40);
      if (e.code === "Space") {
        e.preventDefault();
        this.shoot();
      }
    });
  }

  moveShip(delta) {
    const newLeft = this.ship.offsetLeft + delta;
    const maxLeft = this.gameArea.offsetWidth - this.ship.offsetWidth;
    this.ship.style.left = Math.max(0, Math.min(maxLeft, newLeft)) + "px";
  }

  shoot() {
    if (this.missiles.length > 3) return;

    const missile = document.createElement("div");
    missile.className = "missile";
    missile.style.left = this.ship.offsetLeft + this.ship.offsetWidth / 2 - 4 + "px";
    missile.style.bottom = "70px";

    this.gameArea.appendChild(missile);
    this.missiles.push(missile);
  }

  spawnAnswers() {
    const opts = this.currentQuestion.options;
    const n = opts.length;

    opts.forEach((opt, index) => {
      const answerEl = document.createElement("div");
      answerEl.className = "falling-answer";

      // üî• VOIE D√âDI√âE POUR CHAQUE R√âPONSE
      const lanePercent = ((index + 1) / (n + 1)) * 100;
      answerEl.style.left = lanePercent + "%";

      // üî• Moins d‚Äôattente avant l‚Äôapparition : max 0,5 s
      answerEl.style.animationDelay = `${0.5 * Math.random()}s`;

      // üî• Chute ralentie (dur√©e augment√©e)
      answerEl.style.animationDuration = (STARSHIP_FALL_DURATION / 1000) + "s";

      answerEl.textContent = opt;

      if (opt === this.currentQuestion.a) {
        answerEl.dataset.isCorrect = "true";
      }

      this.gameArea.appendChild(answerEl);
      this.answers.push(answerEl);
    });

    // Quand la bonne r√©ponse est arriv√©e en bas sans √™tre touch√©e ‚Üí faux (sans ouvrir le panneau rouge)
    this.timeoutId = setTimeout(() => {
      const hasCorrect = this.answers.find(a => a.dataset.isCorrect === "true");
      if (hasCorrect) {
        this.resetAnimation();
        // On garde la logique : mauvaise r√©ponse silencieuse (perte de vie mais pas de panneau)
        this.controller.notifyWrongAnswer(null);
      }
    }, STARSHIP_FALL_DURATION + 500);
  }

  gameLoop() {
    this.updateMissiles();
    this.checkCollisions();
    this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
  }

  updateMissiles() {
    for (let i = this.missiles.length - 1; i >= 0; i--) {
      const m = this.missiles[i];
      let bottom = parseFloat(m.style.bottom);
      bottom += 10;
      m.style.bottom = bottom + "px";

      if (bottom > this.gameArea.offsetHeight) {
        m.remove();
        this.missiles.splice(i, 1);
      }
    }
  }

  checkCollisions() {
    for (let i = this.missiles.length - 1; i >= 0; i--) {
      for (let j = this.answers.length - 1; j >= 0; j--) {
        const missile = this.missiles[i];
        const answer = this.answers[j];

        if (this.isColliding(missile, answer)) {
          this.resetAnimation();

          const isCorrect = answer.textContent === this.currentQuestion.a;
          if (isCorrect) {
            this.controller.notifyCorrectAnswer();
          } else {
            // üëâ C‚Äôest ICI que ton "div faux" doit s‚Äôouvrir :
            // on envoie la question au controller pour afficher la correction.
            localScores[currentIndex] = Math.max(0, localScores[currentIndex] - 1);
            updateBars();
            this.controller.notifyWrongAnswer(this.currentQuestion);
          }
          return;
        }
      }
    }
  }

  isColliding(a, b) {
    if (!a || !b) return false;
    const ra = a.getBoundingClientRect();
    const rb = b.getBoundingClientRect();
    return !(
      ra.right < rb.left ||
      ra.left > rb.right ||
      ra.bottom < rb.top ||
      ra.top > rb.bottom   // ‚úÖ correction : on v√©rifie bien que le missile n‚Äôest pas enti√®rement AU-DESSOUS
    );
  }

  clearObjects() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    this.answers.forEach(a => a.remove());
    this.missiles.forEach(m => m.remove());
    this.answers = [];
    this.missiles = [];
  }

  startAnimation() {
    this.gameLoop();
  }

  resetAnimation() {
    cancelAnimationFrame(this.animationFrameId);
    this.clearObjects();
  }
}

window.StarshipGame = StarshipGame;
</script>
