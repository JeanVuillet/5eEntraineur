<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Quiz ‚Äì Les deux empires</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --arena-h: clamp(180px, 36vh, 320px);
      --char-h: clamp(90px, 26vh, 200px);
      --proj-size: clamp(18px, 3vh, 28px);
    }
    * { box-sizing: border-box; }
    body {
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background: linear-gradient(#e0f2fe, #f8fafc);
      color: #222;
      margin: 0;
      padding: clamp(10px, 3vw, 24px);
    }
    .wrap {
      margin: 0 auto;
      max-width: 960px;
      background: #fff8;
      backdrop-filter: blur(4px);
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,.08);
      padding: clamp(12px, 3vw, 24px);
      overflow: hidden;
    }
    h1, h2 { text-align: center; margin: 4px 0 10px; }
    h2 { color: #374151; font-size: clamp(16px, 2.8vw, 22px); }

    #lives { display:flex; justify-content:center; gap:6px; margin-bottom:8px; flex-wrap:wrap; }
    .heart {
      width: clamp(18px, 3.6vw, 28px); height: clamp(18px, 3.6vw, 28px);
      background: radial-gradient(circle at 30% 30%, #ef4444, #b91c1c);
      clip-path: path("M16 28C8 22 2 18 2 11C2 7 5 4 9 4C12 4 14 6 16 8C18 6 20 4 23 4C27 4 30 7 30 11C30 18 24 22 16 28Z");
      filter: drop-shadow(0 1px 1px rgba(0,0,0,.25));
    }
    .heart.off { opacity:.25; filter: grayscale(.7); }

    #mainProgress { background:#e5e7eb; border-radius:14px; overflow:hidden; height:20px; margin-bottom:8px; }
    #mainBar { height:100%; width:0%; background: linear-gradient(90deg,#22c55e,#16a34a); transition:width .4s ease; }
    #subBars { display:grid; grid-template-columns: 1fr 1fr; gap:8px 16px; margin-bottom:8px; }
    .subProgress { background:#e5e7eb; border-radius:10px; height:14px; overflow:hidden; position:relative; }
    .subBar { height:100%; width:0%; background: linear-gradient(90deg,#60a5fa,#2563eb); transition:width .4s ease; }
    .subLabel { position:absolute; top:0; left:6px; font-size:12px; color:#fff; text-shadow:0 0 2px rgba(0,0,0,.5); line-height:14px; font-weight:600; }

    #question { font-size: clamp(16px, 3.5vw, 20px); margin: 12px 0 6px; text-align:center; }
    #feedback { margin: 8px auto 0; text-align:center; min-height: 1.6em; font-weight: 700; }

    #choices { display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin:8px auto; max-width:680px; }
    .choice {
      border:1px solid #d1d5db; border-radius:10px; padding:clamp(8px,2vw,12px); cursor:pointer;
      background:#fff; text-align:center; transition: transform .08s, box-shadow .2s; font-size: clamp(14px, 2.8vw, 16px);
    }
    .choice:hover { box-shadow:0 5px 10px rgba(0,0,0,0.08); transform:translateY(-2px); }
    .choice.correct { background:#dcfce7; border-color:#22c55e; }
    .choice.wrong { background:#fee2e2; border-color:#ef4444; }

    #freeInputZone { display:none; text-align:center; margin-top:8px; }
    #answer { padding:8px; width:min(680px,90%); font-size:clamp(14px, 2.8vw, 16px); }
    #submit { margin-top:8px; padding:10px 14px; background:#22c55e; color:#fff; border:0; border-radius:8px; cursor:pointer; }
    #submit:hover { background:#16a34a; }

    #arena {
      position:relative; height:var(--arena-h); margin-top:10px;
      background: linear-gradient(#f0f9ff, #e0f2fe);
      border-radius:12px; overflow:hidden; box-shadow: inset 0 -6px 0 #cbd5e1;
    }
    #hero, #zombie, #projectile {
      position:absolute; bottom:0; height:var(--char-h);
      max-width:32vw; object-fit:contain; user-select:none; pointer-events:none;
    }
    #hero { left:min(3vw,24px); }
    #zombie { right:min(3vw,24px); transition:right .08s linear; }
    #projectile {
      width:var(--proj-size); height:var(--proj-size);
      background: radial-gradient(circle, #38bdf8 0%, #0284c7 80%);
      border-radius:50%; display:none;
    }

    #overlay { position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:50; color:#fff; text-align:center; padding:20px; }
    #overlay .panel{ background:#0f172a; border-radius:16px; padding:20px; width:min(520px,92%); box-shadow:0 20px 60px rgba(0,0,0,.4); }
    #overlay h3{ margin:0 0 8px; font-size:clamp(18px, 4.6vw, 26px); }
    #overlay button{ margin-top:8px; padding:10px 16px; border:0; border-radius:10px; cursor:pointer; background:#22c55e; color:#fff; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Les deux empires üè∞</h1>
  <h2 id="levelTitle">Niveau 1 : rep√®res</h2>

  <div id="lives"></div>

  <div id="mainProgress"><div id="mainBar"></div></div>
  <p id="general" style="text-align:center; margin:4px 0 8px;">Compteur g√©n√©ral : 0/0</p>
  <div id="subBars"></div>

  <p id="question"></p>
  <div id="choices"></div>
  <div id="freeInputZone">
    <input type="text" id="answer" placeholder="√âcris ta r√©ponse ici" />
    <br />
    <button id="submit">Valider</button>
  </div>
  <p id="feedback"></p>

  <div id="arena">
    <img id="hero" src="img/hero.png" alt="H√©ros" />
    <img id="zombie" src="img/zombi.png" alt="Zombie" />
    <div id="projectile"></div>
  </div>
</div>

<div id="overlay">
  <div class="panel">
    <h3>üíÄ Game Over</h3>
    <p>Tu n‚Äôas plus de c≈ìurs. Recommencer le niveau ?</p>
    <button id="restartBtn">Recommencer</button>
  </div>
</div>

<script>
/* ===== Donn√©es ===== */
const levels=[{
  title:"Niveau 1 : rep√®res",
  placeholder:"√âcris la r√©ponse (dernier palier)",
  requiredPerQuestion:3, startScore:0, wrongPenaltyInput:1,
  questions:[
    { q:"Quel empire se trouve √† l‚ÄôOuest de l‚ÄôEurope au d√©but du Moyen √Çge ?", a:"carolingien", options:["carolingien","byzantin","ottoman","romain d'orient"] },
    { q:"Quel empire se trouve √† l‚ÄôEst de l‚ÄôEurope, centr√© sur Constantinople ?", a:"byzantin", options:["byzantin","carolingien","ottoman","sassanide"] },
    { q:"Quelle est la capitale de l‚ÄôEmpire carolingien ?", a:"Aix-la-Chapelle", acceptable:["aix la chapelle","aix-la-chapelle","aix la Chapelle"], options:["Aix-la-Chapelle","Aixe-la-chapelle","Rome","Constantinople"] },
    { q:"Quelle est la capitale de l‚ÄôEmpire byzantin ?", a:"Constantinople", options:["Constantinople","Aix-la-chapelle","Aix-en-provence","Rome"] },
    { q:"Religion dominante dans l‚ÄôEmpire carolingien ?", a:"catholique", options:["catholique","orthodoxe","islam","arianisme"] },
    { q:"Religion dominante dans l‚ÄôEmpire byzantin ?", a:"orthodoxe", options:["orthodoxe","catholique","islam","arianisme"] }
  ]
}];

/* ===== √âtat ===== */
let currentLevel=0, localScores=[], general=0, currentIndex=-1;
let locked=false, zombieInterval=null, zombiePosition=20, projectileInterval=null, zombiePaused=false;
let lives=4; const MAX_LIVES=4;
let zombieSpeed = 0.75; // üê¢ vitesse un peu r√©duite

/* ===== Refs ===== */
const levelTitle=document.getElementById("levelTitle");
const livesWrap=document.getElementById("lives");
const mainBar=document.getElementById("mainBar");
const subBarsContainer=document.getElementById("subBars");
const generalText=document.getElementById("general");
const qElt=document.getElementById("question");
const feedback=document.getElementById("feedback");
const choicesZone=document.getElementById("choices");
const freeInputZone=document.getElementById("freeInputZone");
const inputElt=document.getElementById("answer");
const submitBtn=document.getElementById("submit");
const arena=document.getElementById("arena");
const zombieElt=document.getElementById("zombie");
const heroElt=document.getElementById("hero");
const projectileElt=document.getElementById("projectile");
const overlay=document.getElementById("overlay");
const restartBtn=document.getElementById("restartBtn");

/* ===== UI vies ===== */
function renderLives(){
  livesWrap.innerHTML="";
  for(let i=0;i<MAX_LIVES;i++){
    const h=document.createElement("div");
    h.className="heart"+(i<lives?"":" off");
    livesWrap.appendChild(h);
  }
}

/* ===== Setup niveau ===== */
function setupLevel(idx){
  const lvl=levels[idx];
  levelTitle.textContent=lvl.title;
  inputElt.placeholder=lvl.placeholder;

  localScores=new Array(lvl.questions.length).fill(lvl.startScore);
  general=0; currentIndex=-1;

  lives=MAX_LIVES; renderLives();

  subBarsContainer.innerHTML="";
  lvl.questions.forEach((_,i)=>{
    const bar=document.createElement("div");
    bar.className="subProgress";
    bar.innerHTML=`<div class="subBar" id="subBar${i}"></div><div class="subLabel">${i+1}</div>`;
    subBarsContainer.appendChild(bar);
  });

  updateBars();
  nextQuestion(false); // reset normal au d√©but
}

function updateBars(){
  const total=levels[currentLevel].questions.length;
  mainBar.style.width=(general/total)*100+"%";
  generalText.textContent=`Compteur g√©n√©ral : ${general}/${total}`;
  const req=levels[currentLevel].requiredPerQuestion;
  levels[currentLevel].questions.forEach((_,i)=>{
    const bar=document.getElementById("subBar"+i);
    const val=Math.max(0,Math.min(localScores[i],req));
    bar.style.width=(val/req)*100+"%";
  });
}

/* ===== Questions ===== */
/** keepZombie=false -> reset au bord droit
 *  keepZombie=true  -> NE PAS reset, repartir de la position actuelle */
function nextQuestion(keepZombie){
  if(!keepZombie){
    stopZombie();
    zombiePosition=20;
    zombieElt.style.right=zombiePosition+"px";
    zombieElt.style.display="block";
  }else{
    // on garde la position et l'affichage actuels
    stopZombie(); // √©tait en pause, on relancera apr√®s le rendu
  }

  zombiePaused=false;
  locked=false;
  feedback.textContent="";

  const lvl=levels[currentLevel];
  if(general>=lvl.questions.length){
    qElt.textContent="üéâ Bravo ! Niveau termin√© !";
    choicesZone.innerHTML=""; freeInputZone.style.display="none";
    return;
  }

  const nxt=findNextIndex(currentIndex);
  currentIndex=nxt;
  renderQuestion();
  startZombie(); // repart soit du bord, soit de la position courante
}

function findNextIndex(fromIdx){
  const lvl=levels[currentLevel], req=lvl.requiredPerQuestion, n=lvl.questions.length;
  for(let i=fromIdx+1;i<n;i++) if(localScores[i]<req) return i;
  for(let i=0;i<=fromIdx;i++) if(localScores[i]<req) return i;
  return null;
}

function renderQuestion(){
  const lvl=levels[currentLevel];
  const q=lvl.questions[currentIndex];
  const progress=localScores[currentIndex];

  qElt.textContent=q.q;
  inputElt.value="";
  choicesZone.innerHTML="";
  freeInputZone.style.display="none";

  if(progress>=lvl.requiredPerQuestion-1){
    freeInputZone.style.display="block";
    inputElt.focus();
  }else{
    const shuffled=[...q.options].sort(()=>Math.random()-0.5);
    shuffled.forEach(opt=>{
      const c=document.createElement("div");
      c.className="choice";
      c.textContent=opt;
      c.addEventListener("click",()=>onChoiceClick(c,opt,q));
      choicesZone.appendChild(c);
    });
  }
}

/* ===== V√©rifs ===== */
function normalize(s){return (s||"").toLowerCase().trim();}
function isCorrectOption(opt,q){return normalize(opt)===normalize(q.a);}
function isCorrectFreeInput(q,s){
  s=normalize(s);
  if(q.acceptable) return q.acceptable.some(v=>normalize(v)===s);
  return s.includes(normalize(q.a));
}

/* ===== R√©ponses ===== */
function onChoiceClick(elt,opt,q){
  if(locked) return;
  const ok=isCorrectOption(opt,q);
  locked=true;

  if(ok){
    elt.classList.add("correct");
    feedback.textContent="‚úÖ Bonne r√©ponse !";
    attack();
    incrementProgress(1);
    setTimeout(()=>nextQuestion(false),900); // bonne r√©ponse -> nouveau zombie
  }else{
    elt.classList.add("wrong");
    wrongAnswerFlow(q);
  }
}

submitBtn.addEventListener("click",()=>{
  if(locked) return;
  const q=levels[currentLevel].questions[currentIndex];
  const ok=isCorrectFreeInput(q,inputElt.value);
  locked=true;

  if(ok){
    feedback.textContent="‚úÖ Bonne r√©ponse !";
    attack();
    incrementProgress(1,true);
    setTimeout(()=>nextQuestion(false),900);
  }else{
    localScores[currentIndex]=Math.max(0,localScores[currentIndex]-levels[currentLevel].wrongPenaltyInput);
    updateBars();
    wrongAnswerFlow(q);
  }
});

/* === Flux ‚Äúmauvaise r√©ponse‚Äù : pause, affiche, nouvelle question, reprise √† la m√™me position === */
function wrongAnswerFlow(q){
  stopZombie(); // pause instantan√©e
  if(freeInputZone.style.display==="none"){
    localScores[currentIndex]=Math.max(0,localScores[currentIndex]-1);
    updateBars();
  }
  feedback.textContent=`‚ùå Mauvaise r√©ponse. Bonne r√©ponse : ${q.a}`;
  setTimeout(()=>{ nextQuestion(true); }, 1500); // üëâ garde la position du zombie
}

function incrementProgress(v,final=false){
  const req=levels[currentLevel].requiredPerQuestion;
  localScores[currentIndex]=Math.min(req,localScores[currentIndex]+v);
  if(final||localScores[currentIndex]===req) general++;
  updateBars();
}

/* ===== Zombie ===== */
function startZombie(){
  stopZombie();
  zombieInterval=setInterval(()=>{
    if(zombiePaused) return;
    zombiePosition+=zombieSpeed; // üê¢ vitesse r√©duite
    zombieElt.style.right=zombiePosition+"px";

    const z=zombieElt.getBoundingClientRect();
    const h=heroElt.getBoundingClientRect();
    if(z.left<=h.right-6){ onZombieHitHero(); }
  },50);
}
function stopZombie(){ clearInterval(zombieInterval); zombieInterval=null; }
function pauseZombie(flag){ zombiePaused=!!flag; }

/* Collision zombie-h√©ros : -1 vie, respawn au bord (m√™me question) */
function onZombieHitHero(){
  stopZombie();
  if(lives>0) lives--;
  renderLives();
  zombieElt.style.display="none";
  feedback.textContent="üí• Le zombie t‚Äôa touch√© ! (-1 c≈ìur)";

  if(lives<=0){ gameOver(); return; }

  setTimeout(()=>{
    zombiePosition=20;
    zombieElt.style.right=zombiePosition+"px";
    zombieElt.style.display="block";
    startZombie();
  },900);
}

/* ===== Tir h√©ros ===== */
function attack(){
  const proj=projectileElt;
  proj.style.display="block";
  const a=arena.getBoundingClientRect();
  const h=heroElt.getBoundingClientRect();
  proj.style.left=(h.right-a.left+8)+"px";
  proj.style.bottom="calc(var(--char-h) * 0.55)";

  let vx=Math.max(12, arena.clientWidth/45);
  clearInterval(projectileInterval);
  projectileInterval=setInterval(()=>{
    const x=(parseFloat(proj.style.left)||0)+vx;
    proj.style.left=x+"px";

    const pR=proj.getBoundingClientRect();
    const zR=zombieElt.getBoundingClientRect();
    if(pR.right>=zR.left){
      clearInterval(projectileInterval);
      proj.style.display="none";
      zombieElt.style.display="none";
      stopZombie();
      setTimeout(()=>{
        zombiePosition=20;
        zombieElt.style.right=zombiePosition+"px";
        zombieElt.style.display="block";
      },400);
    }
    if(x>a.width-10){
      clearInterval(projectileInterval);
      proj.style.display="none";
    }
  },16);
}

/* ===== Game over ===== */
function gameOver(){ locked=true; stopZombie(); overlay.style.display="flex"; }
document.getElementById("restartBtn").addEventListener("click",()=>{
  overlay.style.display="none"; setupLevel(currentLevel);
});

/* Lancement */
setupLevel(0);
</script>
</body>
</html>
