<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>5e Entra√Æneur ‚Äì Quiz Interactif</title>
  <style>
    /* ... (VOS STYLES RESTENT INCHANG√âS) ... */
    :root{--bg:#f8fafc;--card:#fff;--primary:#2563eb;--ok:#16a34a;--warn:#ef4444;--text:#111827;--muted:#6b7280;--shadow:0 10px 25px rgba(0,0,0,.08);--arena-h:clamp(180px,36vh,320px);--char-h:clamp(90px,26vh,200px);--proj-size:clamp(18px,3vh,28px)}*{box-sizing:border-box}body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);background:linear-gradient(#e0f2fe,var(--bg));min-height:100dvh;display:flex;flex-direction:column}header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:14px 18px;background:#fff;box-shadow:var(--shadow);position:sticky;top:0;z-index:20}header h1{font-size:18px;margin:0}#studentBadge{font-size:14px;color:var(--muted)}#logoutBtn{background:#94a3b8!important;color:#fff;padding:6px 10px!important;font-size:14px!important;width:auto!important}#logoutBtn:hover{background:#64748b!important}.wrap{max-width:960px;width:100%;margin:24px auto;padding:0 16px;flex:1}.card{background:var(--card);box-shadow:var(--shadow);border-radius:14px;padding:20px}.form{display:grid;grid-template-columns:1fr;gap:12px;margin-top:10px}label{font-size:14px;color:var(--muted)}input,select,button{width:100%;padding:12px 14px;border-radius:10px;border:1px solid #d1d5db;font-size:16px;outline:none;transition:box-shadow .2s,transform .02s;background:#fff}input:focus,select:focus{box-shadow:0 0 0 3px rgba(37,99,235,.2);border-color:#93c5fd}button{background:var(--primary);color:#fff;border:none;cursor:pointer;font-weight:600}button:hover{filter:brightness(1.05)}button:active{transform:translateY(1px)}.row{display:grid;grid-template-columns:1fr 1fr;gap:12px}.hint{color:var(--muted);font-size:13px;margin-top:6px}.error{color:var(--warn);font-weight:600;margin-top:8px}.ok{color:var(--ok);font-weight:600;margin-top:8px}#game{display:none;margin-top:18px}#playersTable th{font-weight:600;padding:10px;border-bottom:1px solid #e2e8f0;text-align:left}#playersTable td{padding:10px;border-bottom:1px solid #f1f5f9;vertical-align:middle}.player-finished td{background-color:#f0fdf4!important;color:#166534}.player-finished strong{color:#15803d}#recentPlayers tr:nth-child(even):not(.player-finished){background-color:#f8fafc}.action-btn{padding:5px 9px!important;font-size:12px!important;width:auto!important;margin:2px;border-radius:6px}.reset-btn{background:#fee2e2!important;color:#b91c1c}.reset-btn:hover{background:#fecaca!important}.impersonate-btn{background:#e0e7ff!important;color:#3730a3}.impersonate-btn:hover{background:#c7d2fe!important}.questions-list{display:flex;gap:4px;flex-wrap:wrap;margin:4px 0}.question-indicator{width:24px;height:24px;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:700;border:1px solid #e5e7eb}.question-valid{background:#dcfce7;color:#16a34a;border-color:#22c55e}.question-invalid{background:#fef2f2;color:#ef4444;border-color:#fecaca}@media (max-width:640px){.row{grid-template-columns:1fr}}.quiz-container{padding:0;box-shadow:none}.quiz-container h1,.quiz-container h2{text-align:center;margin:4px 0 10px}.quiz-container h2{color:#374151;font-size:clamp(16px,2.8vw,22px)}#lives{display:flex;justify-content:center;gap:6px;margin-bottom:8px;flex-wrap:wrap}.heart{width:clamp(18px,3.6vw,28px);height:clamp(18px,3.6vw,28px);background:radial-gradient(circle at 30% 30%,#ef4444,#b91c1c);clip-path:path("M16 28C8 22 2 18 2 11C2 7 5 4 9 4C12 4 14 6 16 8C18 6 20 4 23 4C27 4 30 7 30 11C30 18 24 22 16 28Z");filter:drop-shadow(0 1px 1px rgba(0,0,0,.25))}.heart.off{opacity:.25;filter:grayscale(.7)}#mainProgress{background:#e5e7eb;border-radius:14px;overflow:hidden;height:20px;margin-bottom:8px}#mainBar{height:100%;width:0;background:linear-gradient(90deg,#22c55e,#16a34a);transition:width .4s ease}#subBars{display:grid;grid-template-columns:1fr 1fr;gap:8px 16px;margin-bottom:8px}.subProgress{background:#e5e7eb;border-radius:10px;height:14px;overflow:hidden;position:relative;cursor:pointer}.subBar{height:100%;width:0;background:linear-gradient(90deg,#60a5fa,#2563eb);transition:width .4s ease}.subLabel{position:absolute;top:0;left:6px;font-size:12px;color:#fff;text-shadow:0 0 2px rgba(0,0,0,.5);line-height:14px;font-weight:600}.subProgress.prof-mode:hover{background:#f0f9ff}#question{font-size:clamp(16px,3.5vw,20px);margin:12px 0 6px;text-align:center}#feedback{margin:8px auto 0;text-align:center;min-height:1.6em;font-weight:700}#choices{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:8px auto;max-width:680px}.choice{border:1px solid #d1d5db;border-radius:10px;padding:clamp(8px,2vw,12px);cursor:pointer;background:#fff;text-align:center;transition:transform .08s,box-shadow .2s;font-size:clamp(14px,2.8vw,16px)}.choice:hover{box-shadow:0 5px 10px rgba(0,0,0,.08);transform:translateY(-2px)}.choice.correct{background:#dcfce7;border-color:#22c55e}.choice.wrong{background:#fee2e2;border-color:#ef4444}#freeInputZone{display:none;text-align:center;margin-top:8px}#answer{padding:8px;width:min(680px,90%);font-size:clamp(14px,2.8vw,16px)}#submit{margin-top:8px;padding:10px 14px;background:#22c55e;color:#fff;border:0;border-radius:8px;cursor:pointer}#submit:hover{background:#16a34a}#arena{position:relative;height:var(--arena-h);margin-top:10px;background:linear-gradient(#f0f9ff,#e0f2fe);border-radius:12px;overflow:hidden;box-shadow:inset 0 -6px 0 #cbd5e1}#hero,#zombie,#projectile{position:absolute;bottom:0;height:var(--char-h);max-width:32vw;object-fit:contain;-webkit-user-select:none;user-select:none;pointer-events:none}#hero{left:min(3vw,24px)}#zombie{right:min(3vw,24px);transition:right .08s linear}#projectile{width:var(--proj-size);height:var(--proj-size);background:radial-gradient(circle,#38bdf8 0%,#0284c7 80%);border-radius:50%;display:none;bottom:calc(var(--char-h)*.55)}#overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:50;color:#fff;text-align:center;padding:20px}#overlay .panel{background:#0f172a;border-radius:16px;padding:20px;width:min(520px,92%);box-shadow:0 20px 60px rgba(0,0,0,.4)}#overlay h3{margin:0 0 8px;font-size:clamp(18px,4.6vw,26px)}#overlay button{margin-top:8px;padding:10px 16px;border:0;border-radius:10px;cursor:pointer;background:#22c55e;color:#fff}#correctionOverlay{position:fixed;inset:0;background:rgba(0,0,0,.85);display:none;align-items:center;justify-content:center;z-index:60;color:#fff;text-align:center;padding:20px}#correctionOverlay .correction-box{background:#fee2e2;color:#b91c1c;border-radius:20px;padding:40px;box-shadow:0 10px 30px rgba(0,0,0,.5);width:min(600px,95%)}#correctionOverlay h2{font-size:clamp(24px,6vw,40px);margin-bottom:10px;color:#b91c1c}#correctionOverlay p{font-size:clamp(18px,4vw,30px);font-weight:700;margin-top:0}.prof-badge{background:#f59e0b;color:#fff;padding:4px 8px;border-radius:6px;font-size:12px;font-weight:700}#profGameControls{display:none;background:#fffbeb;border:1px solid #fde68a;border-radius:12px;padding:12px;margin:12px auto;max-width:680px;text-align:center}#profGameControls button{width:auto;padding:8px 12px;font-size:13px;margin:4px}
  </style>
</head>
<body>
  <header>
    <h1>5e Entra√Æneur</h1>
    <div style="display: flex; align-items: center; gap: 12px;"> 
      <div id="studentBadge">Non connect√©</div>
      <button id="logoutBtn" style="display: none;">Se d√©connecter</button>
    </div>
  </header>

  <main class="wrap">
    <section id="registerCard" class="card">
      <h2>üëã Avant de commencer</h2>
      
      <form id="registerForm" class="form" autocomplete="on">
        <p class="hint">Entre ton <strong>pr√©nom</strong>, <strong>nom</strong> et s√©lectionne ta <strong>classe</strong>.</p>
        <div class="row">
          <div><label for="firstName">Pr√©nom</label><input id="firstName" name="firstName" placeholder="Ex : Jeanne" required /></div>
          <div><label for="lastName">Nom</label><input id="lastName" name="lastName" placeholder="Ex : Martin" required /></div>
        </div>
        <div class="row">
          <div>
            <label for="classroom">Classe</label>
            <select id="classroom" name="classroom">
              <option value="" disabled selected>Choisis ta classe...</option>
              <option value="6D">6eD</option>
              <option value="5B">5eB</option>
              <option value="5C">5eC</option>
              <option value="2A">2de A</option>
              <option value="2CD">2de CD</option>
           </select>
          </div>
          <div><label>&nbsp;</label><button id="startBtn" type="submit">Commencer</button></div>
        </div>
        <div id="formMsg" class="hint"></div>
      </form>

      <div id="profPasswordModal" style="display: none;">
        <h4 style="margin-top:0;">üîê Acc√®s Professeur</h4>
        <p class="hint">Veuillez entrer le mot de passe.</p>
        <div class="form">
            <div>
                <label for="profPassword">Mot de passe</label>
                <input type="password" id="profPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
            </div>
            <div id="profPasswordMsg" class="error" style="margin-bottom: 8px;"></div>
            <button id="validateProfPasswordBtn">Valider</button>
        </div>
      </div>

    </section>

    <section id="game">
      <div class="card quiz-container">
        <h1>üéÆ Quiz</h1>
        <h2 id="levelTitle"></h2>
        <div id="profModeIndicator" style="display: none; text-align: center; margin-bottom: 10px;"></div>
        <p class="hint" id="welcomeText" style="text-align:center;"></p>

        <div id="profGameControls">
          <button id="profSkipLevelBtn" style="background: #6b7280;">Passer le niveau (sans valider)</button>
          <button id="profValidateLevelBtn" style="background: var(--ok);">Valider et Passer</button>
          <button id="profBackToDashboardBtn" style="background: var(--primary);">Retour au Tableau de Bord</button>
        </div>

        <div id="lives"></div>
        <div id="mainProgress"><div id="mainBar"></div></div>
        <p id="general" style="text-align:center; margin:4px 0 8px;">Compteur g√©n√©ral : 0/0</p>
        <div id="subBars"></div>
        <p id="question"></p>
        <div id="choices"></div>
        <div id="freeInputZone">
          <input type="text" id="answer" placeholder="√âcris ta r√©ponse ici" />
          <br /><button id="submit">Valider</button>
        </div>
        <p id="feedback"></p>
        <div id="arena">
          <img id="hero" src="img/hero.png" alt="H√©ros" /><img id="zombie" src="img/zombi.png" alt="Zombie" /><div id="projectile"></div>
        </div>
      </div>
    </section>
    
    <section id="recentPlayers" class="card" style="margin-top: 24px; display: none;"> 
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
        <h2>üìà Tableau des √©l√®ves</h2>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
          <select id="classFilter" class="action-btn" style="width: auto; font-size: 14px; padding: 8px 12px!important; height: 37px; border-color: #d1d5db;">
            <option value="all">Filtrer par classe...</option>
            <option value="all">Toutes les classes</option>
            <option value="6D">6eD</option>
            <option value="5B">5eB</option>
            <option value="5C">5eC</option>
            <option value="2A">2de A</option>
            <option value="2CD">2de CD</option>
          </select>
          <button id="testGameBtn" style="width: auto; padding: 8px 12px; font-size: 14px; background: #f59e0b;">üéÆ Test Game (Local)</button>
          <button id="resetAllBtn" style="width: auto; padding: 8px 12px; font-size: 14px; background: var(--warn);">‚ö†Ô∏è Tout R√©initialiser</button>
        </div>
      </div>
      <table id="playersTable" style="width: 100%; border-collapse: collapse; margin-top: 15px;">
        <thead>
          <tr style="background: #f1f5f9;">
            <th>Pr√©nom et Nom</th><th>Classe</th><th>Progression</th><th>Niveaux Valid√©s</th><th>Actions</th>
          </tr>
        </thead>
        <tbody id="playersBody">
          <tr><td colspan="5" style="text-align: center; padding: 20px;">Chargement...</td></tr>
        </tbody>
      </table>
    </section>

  </main>

  <div id="overlay"><div class="panel"><h3>üíÄ Game Over</h3><p>Tu n'as plus de c≈ìurs. Recommencer le niveau ?</p><button id="restartBtn">Recommencer</button></div></div>
  <div id="correctionOverlay"><div class="correction-box"><h2>‚ùå Erreur ! La bonne r√©ponse √©tait :</h2><p id="correctionText"></p><button id="closeCorrectionBtn">Continuer</button></div></div>

  <script>
    // --- SECTION 0: UI R√©f√©rences & State ---
    const $ = (sel) => document.querySelector(sel);
    const studentBadge = $("#studentBadge"), form = $("#registerForm"), formMsg = $("#formMsg"), registerCard = $("#registerCard");
    const game = $("#game"), startBtn = $("#startBtn"), recentPlayersSection = $("#recentPlayers"), playersBody = $("#playersBody");
    const classFilter = $("#classFilter"), logoutBtn = $("#logoutBtn"), testGameBtn = $("#testGameBtn"), profModeIndicator = $("#profModeIndicator");
    const resetAllBtn = $("#resetAllBtn"), profGameControls = $("#profGameControls");
    const profPasswordModal = $('#profPasswordModal'), profPasswordInput = $('#profPassword'), validateProfPasswordBtn = $('#validateProfPasswordBtn'), profPasswordMsg = $('#profPasswordMsg');

    let isProfessorMode = false, isImpersonating = false, impersonatedPlayer = null;
    const saved = JSON.parse(localStorage.getItem("player") || "null");
    let currentPlayerId = saved ? saved.id : null; 
    let levels = [], questionsLoaded = false;
    let allPlayersData = [];
    let allQuestionsData = {};

    // --- SECTION 1: Logique de connexion et d'affichage ---

    function showStudent(stu) {
      studentBadge.textContent = `${stu.firstName} ${stu.lastName} ‚Äì ${stu.classroom}`;
      $("#welcomeText").textContent = `Bienvenue ${stu.firstName} !`;
      logoutBtn.style.display = 'block';
    }

    function showForm() { 
        registerCard.style.display = "block"; game.style.display = "none"; recentPlayersSection.style.display = "none";
        studentBadge.textContent = "Non connect√©"; logoutBtn.style.display = 'none';
    }

    function hideFormShowGame() {
      registerCard.style.display = "none"; recentPlayersSection.style.display = "none"; game.style.display = "block";
    }
    
    function logout() {
        if(isImpersonating) exitImpersonation();
        localStorage.removeItem("player");
        localStorage.removeItem("profTestData");
        window.location.href = '/';      
    }
    logoutBtn.addEventListener('click', logout);

    function getClassKey(classroom) {
        const cls = classroom.toUpperCase();
        if (cls.startsWith('6')) return '6e';
        if (cls.startsWith('5')) return '5e';
        if (cls.startsWith('2')) return '2de';
        return null;
    }

    async function loadQuestions(classroom) {
      questionsLoaded = false;
      const classKey = getClassKey(classroom);
      if (!classKey) return;
      try {
        const res = await fetch(`/questions/${classKey}`);
        if (!res.ok) throw new Error();
        levels = await res.json(); questionsLoaded = true;
      } catch (err) {
        alert("Erreur critique: Impossible de charger les questions du quiz.");
      }
    }

    async function loadAllQuestionsForProf() {
        try {
            const results = await Promise.all(['6e', '5e', '2de'].map(key => fetch(`/questions/${key}`).then(res => res.json())));
            allQuestionsData = { '6e': results[0], '5e': results[1], '2de': results[2] };
            levels = allQuestionsData['5e']; 
        } catch (err) { console.error("Erreur chargement questions prof :", err); }
    }
    
    (async () => {
        if (saved && saved.id) {
            showStudent(saved);
            if (saved.id === 'prof') {
                isProfessorMode = true;
                registerCard.style.display = "none";
                recentPlayersSection.style.display = "block";
                await loadAllQuestionsForProf();
                fetchPlayers(true);
            } else {
                hideFormShowGame();
                await loadQuestions(saved.classroom);
                initQuiz();
            }
        } else {
            showForm();
        }
    })();

    form?.addEventListener("submit", async (e) => {
        e.preventDefault();
        formMsg.textContent = "";
        startBtn.disabled = true;

        const firstName = $("#firstName").value.trim();
        const lastName = $("#lastName").value.trim();
        
        if (firstName.toLowerCase() === 'jean' && lastName.toLowerCase() === 'vuillet') {
            form.style.display = 'none';
            profPasswordModal.style.display = 'block';
            profPasswordInput.focus();
            startBtn.disabled = false;
            return;
        }

        const classroom = $("#classroom").value;
        if (!firstName || !lastName || !classroom) {
            formMsg.textContent = "‚ùó Pr√©nom, nom et classe sont obligatoires.";
            startBtn.disabled = false;
            return;
        }

        try {
            const res = await fetch('/api/register', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ firstName, lastName, classroom }) });
            const data = await res.json();
            if (!res.ok || !data.ok) throw new Error(data.error || "Erreur d'inscription.");
            const player = { id: data.id, firstName, lastName, classroom };
            localStorage.setItem("player", JSON.stringify(player));
            showStudent(player);
            hideFormShowGame();
            await loadQuestions(player.classroom);
            initQuiz();
        } catch (err) {
            formMsg.textContent = "‚ùå " + err.message;
        } finally {
            startBtn.disabled = false;
        }
    });

    validateProfPasswordBtn.addEventListener('click', handleProfPasswordValidation);
    profPasswordInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') handleProfPasswordValidation();
    });
    function handleProfPasswordValidation() {
        if (profPasswordInput.value === 'Clemenceau1919') {
            localStorage.setItem("player", JSON.stringify({ id: 'prof', firstName: 'Jean', lastName: 'Vuillet', classroom: 'Professeur' }));
            window.location.reload();
        } else {
            profPasswordMsg.textContent = 'Mot de passe incorrect.';
        }
    }

    // --- SECTION 2: Logique du tableau de bord professeur ---
    
    testGameBtn.addEventListener('click', async () => {
        let profTestData = JSON.parse(localStorage.getItem('profTestData'));
        if (!profTestData) {
            profTestData = {
                _id: 'prof-test', firstName: 'Professeur', lastName: 'Test',
                classroom: '5B', validatedQuestions: [], validatedLevels: []
            };
        }
        localStorage.setItem('profTestData', JSON.stringify(profTestData));
        startImpersonation(profTestData, true);
    });

    function renderPlayers(playersToRender) {
        playersBody.innerHTML = '';
        if (playersToRender.length === 0) {
            playersBody.innerHTML = `<tr><td colspan="5">Aucun √©tudiant pour cette classe.</td></tr>`;
            return;
        }
        playersToRender.forEach(player => {
            const classKey = getClassKey(player.classroom);
            const playerLevels = allQuestionsData[classKey] || [];
            const isFinished = playerLevels.length > 0 && player.validatedLevels.length >= playerLevels.length;
            const rowClass = isFinished ? 'class="player-finished"' : '';
            const niveauxValides = player.validatedLevels.length > 0 ? player.validatedLevels.join(', ').replace(/niveau/g, 'N.') : '-';
            const playerJson = encodeURIComponent(JSON.stringify(player));
            const row = `
                <tr ${rowClass}>
                    <td><strong>${player.firstName} ${player.lastName}</strong></td>
                    <td>${player.classroom}</td>
                    <td>${generateQuestionsList(player)}</td>
                    <td>${niveauxValides}</td>
                    <td>
                        <button class="action-btn impersonate-btn" data-player-info='${playerJson}'>Tester en tant que</button>
                        <button class="action-btn reset-btn" data-player-id="${player._id}" data-player-name="${player.firstName} ${player.lastName}">R√©initialiser</button>
                    </td>
                </tr>`;
            playersBody.insertAdjacentHTML('beforeend', row);
        });
    }

    function generateQuestionsList(player) {
        const classKey = getClassKey(player.classroom);
        const playerLevels = allQuestionsData[classKey];
        if (!playerLevels) {
            return `<strong>${player.validatedQuestions.length}</strong>q.`;
        }
        const currentLevelIndex = player.validatedLevels.length;
        if (currentLevelIndex >= playerLevels.length) {
            return `<div style="font-weight: bold;">üèÜ Tous les niveaux termin√©s !</div>`;
        }
        const currentLevel = playerLevels[currentLevelIndex];
        const totalQuestions = currentLevel.questions.length;
        let html = `<div style="font-size: 11px; margin-bottom: 4px;">En cours : <strong>${currentLevel.title}</strong></div><div class="questions-list">`;
        for (let i = 0; i < totalQuestions; i++) {
            const questionId = `${currentLevel.id}-${i}`;
            const isValid = player.validatedQuestions.includes(questionId);
            html += `<div class="question-indicator ${isValid ? 'question-valid' : 'question-invalid'}" title="Q${i + 1}">${i + 1}</div>`;
        }
        const validatedInLevel = player.validatedQuestions.filter(qId => qId.startsWith(currentLevel.id)).length;
        html += `</div><div style="font-size: 10px; margin-top: 2px;">${validatedInLevel}/${totalQuestions} valid√©es</div>`;
        return html;
    }

    async function fetchPlayers(isProf) {
        if (!isProf) return;
        playersBody.innerHTML = `<tr><td colspan="5" style="text-align: center;">Chargement...</td></tr>`;
        try {
            const response = await fetch('/api/players', { cache: 'no-cache' });
            if (!response.ok) throw new Error(`Erreur r√©seau (${response.status}).`);
            allPlayersData = await response.json(); 
            renderPlayers(allPlayersData); 
        } catch (error) {
            playersBody.innerHTML = `<tr><td colspan="5" style="color: var(--warn);">‚ùå Impossible de charger : ${error.message}</td></tr>`;
        }
    }

    classFilter.addEventListener('change', () => {
        const selectedClass = classFilter.value;
        let playersToShow = [...allPlayersData];
        if (selectedClass !== 'all') {
            playersToShow = allPlayersData.filter(player => player.classroom === selectedClass);
        }
        playersToShow.sort((a, b) => a.lastName.localeCompare(b.lastName));
        renderPlayers(playersToShow);
    });

    playersBody.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.matches('.reset-btn')) {
            const playerId = target.dataset.playerId;
            const playerName = target.dataset.playerName;
            if (confirm(`Vraiment r√©initialiser ${playerName} ?`)) {
                try {
                    const res = await fetch('/api/reset-player', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ playerId }) });
                    if (!res.ok) { const err = await res.json(); throw new Error(err.message || '√âchec.'); }
                    await fetchPlayers(true);
                } catch (err) { alert('Erreur: ' + err.message); }
            }
        }
        if (target.matches('.impersonate-btn')) {
            const playerData = JSON.parse(decodeURIComponent(target.dataset.playerInfo));
            startImpersonation(playerData);
        }
    });

    resetAllBtn.addEventListener('click', async () => {
        if (confirm("‚ö†Ô∏è ATTENTION ! ‚ö†Ô∏è\nR√©initialiser TOUS les √©l√®ves ?")) {
            try {
                const res = await fetch('/api/reset-all-players', { method: 'POST' });
                if (!res.ok) { const err = await res.json(); throw new Error(err.message || '√âchec.'); }
                await fetchPlayers(true);
            } catch (err) { alert('Erreur: ' + err.message); }
        }
    });

    async function startImpersonation(playerData, isLocalTest = false) {
        isImpersonating = true;
        impersonatedPlayer = playerData;
        const classKey = getClassKey(playerData.classroom);
        levels = allQuestionsData[classKey] || [];
        hideFormShowGame();
        if (isLocalTest) {
            profModeIndicator.innerHTML = `<span class="prof-badge">üéÆ MODE TEST LOCAL (5e)</span>`;
        } else {
            profModeIndicator.innerHTML = `<span class="prof-badge">üë§ TEST EN TANT QUE : ${playerData.firstName} ${playerData.lastName}</span>`;
        }
        profModeIndicator.style.display = "block";
        profGameControls.style.display = "block";
        setupGameForStudent(playerData);
    }

    function setupGameForStudent(player) {
        const studentLevelIndex = player.validatedLevels ? player.validatedLevels.length : 0;
        if (studentLevelIndex >= levels.length) {
            qElt.textContent = "üéâ Cet √©l√®ve a termin√© tous les niveaux !";
            choicesZone.innerHTML = ""; freeInputZone.style.display = "none"; return;
        }
        setupLevel(studentLevelIndex);
        const levelToLoad = levels[studentLevelIndex];
        const req = levelToLoad.requiredPerQuestion;
        levelToLoad.questions.forEach((q, i) => {
            const qId = `${levelToLoad.id}-${i}`;
            if (player.validatedQuestions.includes(qId)) {
                if (localScores[i] < req) { localScores[i] = req; general++; }
            }
        });
        updateBars();
    }

    async function exitImpersonation() {
        isImpersonating = false;
        impersonatedPlayer = null;
        game.style.display = "none";
        recentPlayersSection.style.display = "block";
        profGameControls.style.display = "none";
        // --- DEBUG ---
        console.log("%c[DEBUG] Re-chargement des donn√©es des √©l√®ves...", "color: blue; font-weight: bold;");
        await fetchPlayers(true);
        console.log("[DEBUG] Donn√©es du tableau de bord mises √† jour (c√¥t√© client):", allPlayersData);
    }
    
    $('#profBackToDashboardBtn').addEventListener('click', exitImpersonation);
    $('#profSkipLevelBtn').addEventListener('click', () => { if (currentLevel < levels.length - 1) setupLevel(currentLevel + 1); });
    $('#profValidateLevelBtn').addEventListener('click', async () => {
        if (!impersonatedPlayer || currentLevel >= levels.length) return;
        const levelToValidate = levels[currentLevel];
        impersonatedPlayer.validatedLevels.push(levelToValidate.id);
        levelToValidate.questions.forEach((q, i) => {
            const qId = `${levelToValidate.id}-${i}`;
            if (!impersonatedPlayer.validatedQuestions.includes(qId)) impersonatedPlayer.validatedQuestions.push(qId);
        });
        await saveProgress('level', levelToValidate.id, impersonatedPlayer._id);
        for(let i = 0; i < levelToValidate.questions.length; i++) {
            await saveProgress('question', `${levelToValidate.id}-${i}`, impersonatedPlayer._id);
        }
        feedback.textContent = `‚úÖ Niveau valid√© pour ${impersonatedPlayer.firstName} !`;
        setTimeout(() => { feedback.textContent = ""; setupGameForStudent(impersonatedPlayer); }, 1500);
    });

    // --- SECTION 3: Logique principale du Quiz ---
    
    // Ajout pour suivre l'√©tat des touches R et T
    let isRKeyDown = false;
    let isTKeyDown = false;
    document.addEventListener('keydown', e => {
        if (e.key.toLowerCase() === 'r') isRKeyDown = true;
        if (e.key.toLowerCase() === 't') isTKeyDown = true;
    });
    document.addEventListener('keyup', e => {
        if (e.key.toLowerCase() === 'r') isRKeyDown = false;
        if (e.key.toLowerCase() === 't') isTKeyDown = false;
    });
    window.addEventListener('blur', () => { // R√©initialise si l'utilisateur quitte la fen√™tre
        isRKeyDown = false;
        isTKeyDown = false;
    });
    
    let currentLevel = 0, localScores = [], general = 0, currentIndex = -1, locked = false;
    let lives = 4; const MAX_LIVES = 4;
    const ZOMBIE_TIME_SECS = 25, ZOMBIE_TIME_FINAL_SECS = 40, INTERVAL_MS = 20;
    const levelTitle = $("#levelTitle"), livesWrap = $("#lives"), mainBar = $("#mainBar"), subBarsContainer = $("#subBars");
    const generalText = $("#general"), qElt = $("#question"), feedback = $("#feedback"), choicesZone = $("#choices");
    const freeInputZone = $("#freeInputZone"), inputElt = $("#answer"), submitBtn = $("#submit"), arena = $("#arena");
    const zombieElt = $("#zombie"), heroElt = $("#hero"), projectileElt = $("#projectile"), overlay = $("#overlay");
    const restartBtn = $("#restartBtn"), correctionOverlay = $("#correctionOverlay"), correctionText = $("#correctionText");
    const closeCorrectionBtn = $("#closeCorrectionBtn");
    
    async function saveProgress(progressType, value, forPlayerId = null) {
        const playerIdToSave = forPlayerId || currentPlayerId;

        // --- DEBUG ---
        console.log(`%c[CLIENT] ---> ENVOI: Sauvegarde de '${progressType}: ${value}' pour l'ID ${playerIdToSave}`, "color: green;");

        if (playerIdToSave === 'prof-test') {
            let profTestData = JSON.parse(localStorage.getItem('profTestData'));
            if (progressType === 'level' && !profTestData.validatedLevels.includes(value)) profTestData.validatedLevels.push(value);
            if (progressType === 'question' && !profTestData.validatedQuestions.includes(value)) profTestData.validatedQuestions.push(value);
            localStorage.setItem('profTestData', JSON.stringify(profTestData));
            impersonatedPlayer = profTestData;
            return;
        }

        if (!playerIdToSave || playerIdToSave === 'prof') return;
        
        try {
            const res = await fetch('/api/save-progress', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ playerId: playerIdToSave, progressType, value }) });
            // --- DEBUG ---
            console.log(`%c[CLIENT] <--- R√âPONSE SERVEUR: Status ${res.status}`, "color: darkorange;");
            if (!res.ok) throw new Error('√âchec de la sauvegarde.');
        } catch (error) { console.error("‚ùå √âchec critique de la sauvegarde:", error); }
    }

    function initQuiz() { if (levels.length > 0) setupLevel(0); }
    function renderLives(){ livesWrap.innerHTML=""; for(let i=0;i<MAX_LIVES;i++){ const h=document.createElement("div"); h.className="heart"+(i<lives?"":" off"); livesWrap.appendChild(h); } }

    function setupLevel(idx){
      const lvl = levels[idx];
      currentLevel = idx; levelTitle.textContent = lvl.title;
      localScores = new Array(lvl.questions.length).fill(0);
      general = 0; currentIndex = -1; lives = MAX_LIVES; renderLives();
      subBarsContainer.innerHTML = "";
      lvl.questions.forEach((_,i)=>{
        const bar=document.createElement("div"); 
        bar.className="subProgress prof-mode"; // Rendu cliquable pour tous
        bar.innerHTML=`<div class="subBar" id="subBar${i}"></div><div class="subLabel">${i + 1}</div>`;
        bar.addEventListener('click', () => handleBarClick(i));
        subBarsContainer.appendChild(bar);
      });
      updateBars(); nextQuestion(false); 
    }

    function handleBarClick(questionIndex) {
      // Condition ajout√©e : Pour un √©l√®ve, les touches R et T doivent √™tre maintenues.
      if (!isProfessorMode && !(isRKeyDown && isTKeyDown)) {
        // Si c'est un √©l√®ve et que les touches ne sont pas enfonc√©es, on ne fait rien.
        // Le mode professeur/impersonation n'est pas affect√©.
        return;
      }
        
      if (locked) return;
      const lvl = levels[currentLevel], req = lvl.requiredPerQuestion;
      const oldScore = localScores[questionIndex];
      if (oldScore < req) {
          localScores[questionIndex] = req;
          if(oldScore < req) general++;
          updateBars();
          
          const questionIdToSave = `${lvl.id}-${questionIndex}`;
          // Sauvegarde syst√©matique lors du clic, g√©r√©e par saveProgress
          saveProgress('question', questionIdToSave, isImpersonating ? impersonatedPlayer._id : currentPlayerId);
      }
      if (general >= lvl.questions.length) {
        nextQuestion(false); // Relance le check de fin de niveau
      }
    }
    
    function updateBars() {
        if (!levels[currentLevel]) return;
        const lvl = levels[currentLevel], total = lvl.questions.length, req = lvl.requiredPerQuestion;
        mainBar.style.width = (general / total) * 100 + "%";
        generalText.textContent = `Compteur g√©n√©ral : ${general}/${total}`;
        lvl.questions.forEach((_, i) => {
            const bar = $(`#subBar${i}`);
            if (bar) bar.style.width = (Math.min(localScores[i], req) / req) * 100 + "%";
        });
    }

    function findNextIndex(fromIdx){
      const lvl=levels[currentLevel], req=lvl.requiredPerQuestion, n=lvl.questions.length;
      for(let i=fromIdx+1;i<n;i++) if(localScores[i]<req) return i;
      for(let i=0;i<=fromIdx;i++) if(localScores[i]<req) return i;
      return null;
    }

    function nextQuestion(keepZombie) {
        if (!keepZombie) { stopZombie(); }
        locked = false; feedback.textContent = "";
        const lvl = levels[currentLevel];
        if (general >= lvl.questions.length) {
            console.log(`%c[CLIENT] üéâ NIVEAU TERMIN√â ! Sauvegarde du niveau '${lvl.id}'...`, "color: #0077cc; font-weight: bold; font-size: 1.1em;");
            if (isImpersonating) { feedback.textContent = `Niveau termin√©. Validez via les boutons.`; return; }
            qElt.textContent = `üéâ Bravo ! ${lvl.title} termin√© !`;
            choicesZone.innerHTML = ""; freeInputZone.style.display = "none";
            saveProgress('level', lvl.id);
            setTimeout(() => {
                console.log(`[CLIENT] ‚è∞ setTimeout fired. Tentative de chargement du niveau suivant.`);
                if (currentLevel < levels.length - 1) {
                    setupLevel(currentLevel + 1);
                } else {
                    qElt.textContent = "üéâ F√©licitations ! Tu as termin√© tous les niveaux !";
                }
            }, 2000);
            return;
        }
        currentIndex = findNextIndex(currentIndex);
        renderQuestion();
        const isInteractiveMode = !isProfessorMode || isImpersonating;
        if (isInteractiveMode) startZombie();
    }

    function renderQuestion() {
        if (currentIndex === null) return;
        const lvl = levels[currentLevel], q = lvl.questions[currentIndex];
        const progress = localScores[currentIndex];
        qElt.textContent = q.q; inputElt.value = "";
        choicesZone.innerHTML = ""; freeInputZone.style.display = "none";
        if (isProfessorMode && !isImpersonating) return;
        if (progress >= lvl.requiredPerQuestion - 1) {
            freeInputZone.style.display = "block"; inputElt.focus();
        } else {
            [...q.options].sort(() => Math.random() - 0.5).forEach(opt => {
                const c = document.createElement("div"); c.className = "choice"; c.textContent = opt;
                c.addEventListener("click", () => onChoiceClick(c, opt, q));
                choicesZone.appendChild(c);
            });
        }
    }

    function onChoiceClick(elt, opt, q) {
        if (locked || (isProfessorMode && !isImpersonating)) return;
        const ok = isCorrectOption(opt, q); locked = true;
        if (ok) {
            elt.classList.add("correct"); feedback.textContent = "‚úÖ Bonne r√©ponse !";
            attack(); 
            incrementProgress(1);
            setTimeout(() => nextQuestion(false), 900);
        } else {
            elt.classList.add("wrong"); wrongAnswerFlow(q);
        }
    }
    
    function normalize(s){return (s||"").toLowerCase().trim();}
    function isCorrectOption(opt,q){return normalize(opt)===normalize(q.a);}
    function isCorrectFreeInput(q,s){
      s=normalize(s);
      return (q.acceptable || []).map(normalize).includes(s) || s.includes(normalize(q.a));
    }

    submitBtn.addEventListener("click", () => {
        if (locked || (isProfessorMode && !isImpersonating)) return;
        const q = levels[currentLevel].questions[currentIndex];
        const ok = isCorrectFreeInput(q, inputElt.value); locked = true;
        if (ok) {
            feedback.textContent = "‚úÖ Bonne r√©ponse !";
            attack(); 
            incrementProgress(1);
            setTimeout(() => nextQuestion(false), 900);
        } else {
            localScores[currentIndex] = Math.max(0, localScores[currentIndex] - (levels[currentLevel].wrongPenaltyInput || 1));
            updateBars(); wrongAnswerFlow(q);
        }
    });

    closeCorrectionBtn.addEventListener("click", () => {
        correctionOverlay.style.display = "none"; nextQuestion(true);
    });

    function wrongAnswerFlow(q) {
        if (isProfessorMode && !isImpersonating) return;
        stopZombie();
        if (freeInputZone.style.display === "none") {
            localScores[currentIndex] = Math.max(0, localScores[currentIndex] - 1); updateBars();
        }
        feedback.textContent = `‚ùå Mauvaise r√©ponse...`;
        correctionText.textContent = q.a;
        correctionOverlay.style.display = "flex";
    }

    function incrementProgress(v) {
        const lvl = levels[currentLevel];
        if (!lvl || !lvl.questions[currentIndex]) return;
        
        const req = lvl.requiredPerQuestion;
        const oldScore = localScores[currentIndex];
        localScores[currentIndex] = Math.min(req, localScores[currentIndex] + v);
        
        if (oldScore < req && localScores[currentIndex] >= req) {
            general++;
            saveProgress('question', lvl.id + '-' + currentIndex);
        }
        updateBars();
    }
    
    function decreaseLives(){
      if (isProfessorMode && !isImpersonating) return;
      lives=Math.max(0,lives-1); renderLives();
      if(lives===0){ stopZombie(); overlay.style.display="flex"; zombieElt.style.display="none"; }
    }

    restartBtn.addEventListener("click",()=>{
        overlay.style.display="none"; setupLevel(currentLevel); 
    });

    let zombieInterval = null, zombiePosition = 20, projectileInterval = null, zombiePaused = false;
    
    function startZombie(){
      if(zombieInterval) return;
      const lvl=levels[currentLevel], isFinal=currentIndex !== null && localScores[currentIndex]>=lvl.requiredPerQuestion-1;
      const timeLimitSecs = isFinal ? ZOMBIE_TIME_FINAL_SECS : ZOMBIE_TIME_SECS;
      const arenaWidth = arena.offsetWidth, zombieWidth = zombieElt.offsetWidth;
      const maxDistance = arenaWidth - zombieWidth - heroElt.offsetWidth - 30;
      const speed = maxDistance / (timeLimitSecs * 1000); 

      zombieInterval=setInterval(()=>{
        if(locked || zombiePaused) return;
        zombiePosition += speed * INTERVAL_MS; 
        zombieElt.style.right=zombiePosition+"px";
        if(zombiePosition>maxDistance){
          stopZombie(); decreaseLives();
          if(lives>0) {
            locked=true; feedback.textContent=`ü§ï -1 c≈ìur`;
            setTimeout(()=>nextQuestion(false), 1500); 
          }
        }
      },INTERVAL_MS);
    }

    function pauseZombieMovement() {
        if(zombieInterval) clearInterval(zombieInterval);
        zombieInterval = null;
    }

    function stopZombie(){
      pauseZombieMovement();
      zombiePosition = 20;
      zombieElt.style.right = zombiePosition + "px";
      zombieElt.style.display = 'block';
    }

    function attack() {
      if (projectileInterval || (isProfessorMode && !isImpersonating)) return;
      pauseZombieMovement();
      zombiePaused = true;
      projectileElt.style.display = "block";
      
      let projPos = heroElt.offsetWidth;
      const zombieRight = parseFloat(zombieElt.style.right);
      const PROJ_SPEED = 20;

      projectileInterval = setInterval(() => {
        projPos += PROJ_SPEED;
        projectileElt.style.left = projPos + "px";

        if (projPos >= arena.offsetWidth - zombieRight - (zombieElt.offsetWidth / 2)) {
          clearInterval(projectileInterval);
          projectileInterval = null;
          projectileElt.style.display = "none";
          projectileElt.style.left = "0px";
          zombieElt.style.display = 'none';
          zombiePaused = false;
        }
      }, INTERVAL_MS);
    }
  </script>
</body>
</html>